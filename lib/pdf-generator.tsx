import { Document, Page, Text, View, StyleSheet, Font } from '@react-pdf/renderer'
import type { Job, MatchRecord, Cluster, TransactionRecord } from "@/types/@types";

interface PdfData {
  job: Job;
  stats: {
    total_payouts: number;
    total_ledger: number;
    matched_count: number;
    unmatched_count: number;
    match_rate: number;
    total_unmatched_amount: number;
  };
  matches: (MatchRecord & { payout: TransactionRecord; ledger: TransactionRecord })[];
  clusters: Cluster[];
}

function formatCents(cents: number): string {
  if (!cents && cents !== 0) return "$0.00";
  return (cents / 100).toLocaleString("en-US", {
    style: "currency",
    currency: "USD",
  });
}

function safeFormatCents(cents: number | undefined): string {
  if (cents === undefined || cents === null) return "$0.00";
  return formatCents(cents);
}

// Define styles
const styles = StyleSheet.create({
  page: {
    padding: 30,
    fontFamily: 'Helvetica',
  },
  title: {
    fontSize: 24,
    marginBottom: 10,
    textAlign: 'center',
    fontWeight: 'bold',
  },
  subtitle: {
    fontSize: 14,
    marginBottom: 5,
    textAlign: 'center',
  },
  date: {
    fontSize: 10,
    color: '#666666',
    marginBottom: 20,
    textAlign: 'center',
  },
  sectionTitle: {
    fontSize: 16,
    marginBottom: 10,
    fontWeight: 'bold',
  },
  text: {
    fontSize: 10,
    marginBottom: 5,
  },
  table: {
    marginBottom: 20,
  },
  tableRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    paddingVertical: 5,
  },
  tableHeader: {
    backgroundColor: '#f5f5f5',
    fontWeight: 'bold',
  },
  tableCell: {
    paddingHorizontal: 5,
    fontSize: 8,
  },
  clusterContainer: {
    marginBottom: 15,
  },
  clusterTitle: {
    fontSize: 12,
    fontWeight: 'bold',
    marginBottom: 3,
  },
  clusterMeta: {
    fontSize: 9,
    color: '#666666',
    marginBottom: 3,
  },
  clusterNotes: {
    fontSize: 9,
    marginBottom: 3,
  },
  footer: {
    position: 'absolute',
    bottom: 30,
    left: 30,
    right: 30,
    textAlign: 'center',
    fontSize: 8,
    color: '#999999',
  },
});

export async function generatePDFReport(data: PdfData): Promise<Buffer> {
  return new Promise(async (resolve, reject) => {
    try {
      const { renderToStream } = await import('@react-pdf/renderer');
      
      // Create PDF document
      const MyDocument = () => (
        <Document>
          <Page size="A4" style={styles.page}>
            {/* Cover Page */}
            <Text style={styles.title}>Reconciliation Report</Text>
            <Text style={styles.subtitle}>{data.job.name || "Untitled Job"}</Text>
            <Text style={styles.date}>
              Generated: {new Date().toLocaleString()}
            </Text>
            
            {/* Summary Statistics */}
            <Text style={styles.sectionTitle}>Summary Statistics</Text>
            <View>
              <Text style={styles.text}>Total Payouts: {data.stats?.total_payouts?.toLocaleString() || 0}</Text>
              <Text style={styles.text}>Total Ledger Entries: {data.stats?.total_ledger?.toLocaleString() || 0}</Text>
              <Text style={styles.text}>Matched Transactions: {data.stats?.matched_count?.toLocaleString() || 0}</Text>
              <Text style={styles.text}>Unmatched Transactions: {data.stats?.unmatched_count?.toLocaleString() || 0}</Text>
              <Text style={styles.text}>Match Rate: {((data.stats?.match_rate || 0) * 100).toFixed(1)}%</Text>
              <Text style={styles.text}>Total Unmatched Amount: {formatCents(data.stats?.total_unmatched_amount || 0)}</Text>
            </View>
            
            {/* Footer */}
            <Text style={styles.footer} fixed>
              Page 1 of 1 | Generated by Reconciliation Assistant
            </Text>
          </Page>

          {/* Match Summary Page */}
          {data.matches && data.matches.length > 0 && (
            <Page size="A4" style={styles.page}>
              <Text style={styles.sectionTitle}>Match Summary</Text>
              
              {/* Table Header */}
              <View style={[styles.tableRow, styles.tableHeader]}>
                <Text style={[styles.tableCell, { width: '12%' }]}>Type</Text>
                <Text style={[styles.tableCell, { width: '22%' }]}>Payout ID</Text>
                <Text style={[styles.tableCell, { width: '22%' }]}>Ledger ID</Text>
                <Text style={[styles.tableCell, { width: '15%' }]}>Amount</Text>
                <Text style={[styles.tableCell, { width: '10%' }]}>Score</Text>
                <Text style={[styles.tableCell, { width: '19%' }]}>Confidence</Text>
              </View>
              
              {/* Table Rows */}
              {data.matches.slice(0, 50).map((match, index) => (
                <View key={index} style={styles.tableRow}>
                  <Text style={[styles.tableCell, { width: '12%' }]}>{match.match_type || "-"}</Text>
                  <Text style={[styles.tableCell, { width: '22%' }]}>
                    {(match.payout?.tx_id || "-").slice(0, 12)}
                  </Text>
                  <Text style={[styles.tableCell, { width: '22%' }]}>
                    {(match.ledger?.tx_id || "-").slice(0, 12)}
                  </Text>
                  <Text style={[styles.tableCell, { width: '15%' }]}>
                    {safeFormatCents(match.payout?.amount_cents)}
                  </Text>
                  <Text style={[styles.tableCell, { width: '10%' }]}>
                    {((match.score || 0) * 100).toFixed(0)}%
                  </Text>
                  <Text style={[styles.tableCell, { width: '19%' }]}>
                    {match.confidence_level || "-"}
                  </Text>
                </View>
              ))}
              
              {data.matches.length > 50 && (
                <Text style={styles.text}>
                  ... and {data.matches.length - 50} more matches
                </Text>
              )}
              
              <Text style={[styles.footer, { bottom: 30 }]} fixed>
                Page 2 of {2 + Math.ceil((data.clusters?.length || 0) / 10)} | Generated by Reconciliation Assistant
              </Text>
            </Page>
          )}

          {/* Cluster Pages */}
          {data.clusters && data.clusters.length > 0 && (
            <>
              {Array.from({ length: Math.ceil(data.clusters.length / 10) }).map((_, pageIndex) => (
                <Page key={pageIndex} size="A4" style={styles.page}>
                  <Text style={styles.sectionTitle}>Exception Clusters</Text>
                  
                  {data.clusters.slice(pageIndex * 10, pageIndex * 10 + 10).map((cluster, clusterIndex) => (
                    <View key={clusterIndex} style={styles.clusterContainer}>
                      <Text style={styles.clusterTitle}>
                        {pageIndex * 10 + clusterIndex + 1}. {cluster.merchant_name || "Unknown Merchant"}
                      </Text>
                      <Text style={styles.clusterMeta}>
                        Amount: {safeFormatCents(cluster.total_amount_cents || cluster.amount)} | 
                        Transactions: {cluster.size || cluster.records?.length || 0} | 
                        Status: {cluster.status || 'unknown'}
                      </Text>
                      {cluster.notes && (
                        <Text style={styles.clusterNotes}>Notes: {cluster.notes}</Text>
                      )}
                      {cluster.llm_summary && (
                        <Text style={[styles.clusterNotes, { fontStyle: 'italic' }]}>
                          AI Summary: {cluster.llm_summary}
                        </Text>
                      )}
                      {cluster.suggested_action && (
                        <Text style={styles.clusterNotes}>
                          Suggested Action: {cluster.suggested_action}
                        </Text>
                      )}
                    </View>
                  ))}
                  
                  <Text style={[styles.footer, { bottom: 30 }]} fixed>
                    Page {3 + pageIndex} of {2 + Math.ceil((data.clusters?.length || 0) / 10)} | Generated by Reconciliation Assistant
                  </Text>
                </Page>
              ))}
            </>
          )}
        </Document>
      );

      // Render PDF to stream
      const stream = await renderToStream(<MyDocument />);
      
      // Collect stream chunks
      const chunks: Buffer[] = [];
      stream.on('data', (chunk: Buffer) => chunks.push(chunk));
      stream.on('end', () => resolve(Buffer.concat(chunks)));
      stream.on('error', reject);
      
    } catch (error) {
      console.error('Error in PDF generation:', error);
      reject(error);
    }
  });
}